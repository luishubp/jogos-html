<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Shift</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: #000; font-family: 'Arial Black', Arial, sans-serif; }
        canvas { display: block; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let gameState = 'menu'; // menu, playing, gameover
        let score = 0;
        let highScore = localStorage.getItem('neonshift_hs') || 0;
        let speed = 200;
        let gameTime = 0;
        let audioCtx;

        // Lanes
        const lanes = [0.25, 0.5, 0.75];
        let player = {
            lane: 1,
            x: 0,
            y: 0,
            size: 18,
            color: '#00ffff',
            trail: []
        };

        // Game objects
        let obstacles = [];
        let particles = [];
        let keys = {};
        let mouseX = 0;

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            player.y = height * 0.5;
            updateLanes();
        }
        function updateLanes() {
            player.x = width * lanes[player.lane];
        }
        window.addEventListener('resize', resize);
        resize();

        // Audio
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        function playBeep(freq, duration, type = 'sine') {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = freq;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // Input
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (gameState === 'gameover' && (e.key === 'Enter' || e.key === ' ')) {
                restart();
            }
        });
        window.addEventListener('keyup', e => keys[e.key] = false);
        function handleInput(e) {
            e.preventDefault();
            let tx = 0;
            if (e.touches) {
                tx = e.touches[0].clientX;
            } else {
                tx = e.clientX;
            }
            const zone = tx / width;
            if (zone < 1/3) player.lane = 0;
            else if (zone < 2/3) player.lane = 1;
            else player.lane = 2;
            updateLanes();
            if (gameState === 'menu' || gameState === 'gameover') {
                restart();
            }
        }

        // Spawn
        function spawnObstacle() {
            const lane = Math.floor(Math.random() * 3);
            obstacles.push({
                x: width + 50,
                lane: lane,
                size: 20 + Math.random() * 10,
                color: ['#ff00ff', '#ffff00', '#ff8000'][Math.floor(Math.random() * 3)],
                type: 'obstacle'
            });
        }
        function spawnCollectible() {
            const lane = Math.floor(Math.random() * 3);
            obstacles.push({
                x: width + 50,
                lane: lane,
                size: 12,
                color: '#00ff00',
                type: 'collect',
                rot: 0
            });
        }

        // Particles
        function spawnParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 100,
                    vy: (Math.random() - 0.5) * 100,
                    life: 1,
                    maxLife: 30 + Math.random() * 20,
                    size: 2 + Math.random() * 4,
                    color: color
                });
            }
        }

        // Draw star
        function drawStar(cx, cy, spikes, outer, inner, color) {
            ctx.save();
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.translate(cx, cy);
            ctx.moveTo(0, -outer);
            for (let i = 0; i < spikes; i++) {
                ctx.rotate(Math.PI / spikes);
                ctx.lineTo(0, -inner);
                ctx.rotate(Math.PI / spikes);
                ctx.lineTo(0, -outer);
            }
            ctx.fill();
            ctx.restore();
        }

        // Update
        function update(dt) {
            if (gameState !== 'playing') return;

            gameTime += dt;
            score = Math.floor(gameTime * 10);
            speed = 200 + score * 0.3;

            // Player trail
            player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 15) player.trail.shift();

            // Controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.lane = Math.max(0, player.lane - 1);
                updateLanes();
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.lane = Math.min(2, player.lane + 1);
                updateLanes();
            }

            // Spawn
            if (Math.random() < 0.015 + score / 200000) spawnObstacle();
            if (Math.random() < 0.008) spawnCollectible();

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= speed * dt;
                if (obs.type === 'collect') obs.rot += dt * 5;

                if (obs.x + obs.size < 0) {
                    obstacles.splice(i, 1);
                    continue;
                }

                // Collision
                const dx = player.x - obs.x;
                const dy = player.y - (height * lanes[obs.lane]);
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.size + obs.size / 2) {
                    if (obs.type === 'obstacle') {
                        playBeep(150, 0.4, 'sawtooth');
                        gameState = 'gameover';
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('neonshift_hs', highScore);
                        }
                        spawnParticles(player.x, player.y, '#ff0000', 20);
                    } else {
                        playBeep(800, 0.1);
                        score += 100;
                        spawnParticles(obs.x, height * lanes[obs.lane], obs.color);
                        obstacles.splice(i, 1);
                    }
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life--;
                p.vx *= 0.98;
                p.vy *= 0.98;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Draw
        function draw() {
            // Clear with gradient
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#001122');
            grad.addColorStop(1, '#000011');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // Grid lines for speed
            ctx.strokeStyle = '#112244';
            ctx.lineWidth = 1;
            for (let i = 0; i < width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }

            if (gameState === 'playing') {
                // Particles
                for (let p of particles) {
                    const alpha = p.life / p.maxLife;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Obstacles / Collectibles
                for (let obs of obstacles) {
                    ctx.save();
                    ctx.shadowColor = obs.color;
                    ctx.shadowBlur = 25;
                    const ox = obs.x;
                    const oy = height * lanes[obs.lane];
                    if (obs.type === 'obstacle') {
                        ctx.fillStyle = obs.color;
                        ctx.beginPath();
                        ctx.arc(ox, oy, obs.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.translate(ox, oy);
                        ctx.rotate(obs.rot);
                        drawStar(0, 0, 5, 15, 5, obs.color);
                    }
                    ctx.restore();
                }

                // Player trail
                for (let i = 0; i < player.trail.length; i++) {
                    const alpha = i / player.trail.length;
                    ctx.save();
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.shadowColor = player.color;
                    ctx.shadowBlur = 10 + alpha * 15;
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.arc(player.trail[i].x, player.trail[i].y, player.size * (alpha * 0.8 + 0.2), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Player
                ctx.save();
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 30;
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 50;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();

                // UI
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'left';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText(`Pontos: ${score}`, 20, 50);
                ctx.fillText(`Melhor: ${highScore}`, 20, 90);

            } else if (gameState === 'menu') {
                // Title
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 72px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 40;
                ctx.fillText('Neon Shift', width / 2, height / 2 - 50);

                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.fillText('Toque ou clique para jogar!', width / 2, height / 2 + 20);
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Toque na zona da faixa desejada (esq/centro/dir)', width / 2, height / 2 + 60);
                ctx.fillText('Setas ← → no PC', width / 2, height / 2 + 90);

            } else if (gameState === 'gameover') {
                // Game Over
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 40;
                ctx.fillText('Fim de Jogo', width / 2, height / 2 - 80);

                ctx.font = 'bold 36px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
                ctx.fillText(`Pontos: ${score}`, width / 2, height / 2 - 20);
                ctx.fillText(`Melhor: ${highScore}`, width / 2, height / 2 + 20);

                ctx.font = 'bold 28px Arial';
                ctx.fillText('Toque ou Enter/Espaço para jogar novamente!', width / 2, height / 2 + 80);
            }
        }

        // Restart
        function restart() {
            gameState = 'playing';
            score = 0;
            gameTime = 0;
            speed = 200;
            obstacles = [];
            particles = [];
            player.trail = [];
            player.lane = 1;
            updateLanes();
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(time) {
            const dt = Math.min((time - lastTime) / 16.666, 3); // Cap dt
            lastTime = time;
            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
